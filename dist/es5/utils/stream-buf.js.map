{"version":3,"file":"stream-buf.js","names":["Stream","require","utils","StringBuf","StringChunk","data","encoding","_data","_encoding","toBuffer","length","target","targetOffset","offset","copy","_buffer","Buffer","from","StringBufChunk","_buf","BufferChunk","ReadWriteBuf","size","buffer","alloc","iRead","iWrite","buf","undefined","chunk","Math","min","StreamBuf","options","bufSize","buffers","batch","corked","inPos","outPos","pipes","paused","inherits","Duplex","concat","map","rwBuf","_getWritableBuffer","last","full","push","_pipe","write","pipe","Promise","resolve","all","_writeToBuffers","inLen","callback","Function","nop","String","ArrayBuffer","Error","shift","process","nextTick","emit","cork","_flush","uncork","end","writeComplete","error","forEach","read","eod","first","filter","Boolean","setEncoding","pause","resume","isPaused","destination","unpipe","unshift","wrap","module","exports"],"sources":["../../../lib/utils/stream-buf.js"],"sourcesContent":["/* eslint-disable max-classes-per-file */\nconst Stream = require('readable-stream');\n\nconst utils = require('./utils');\nconst StringBuf = require('./string-buf');\n\n// =============================================================================\n// data chunks - encapsulating incoming data\nclass StringChunk {\n  constructor(data, encoding) {\n    this._data = data;\n    this._encoding = encoding;\n  }\n\n  get length() {\n    return this.toBuffer().length;\n  }\n\n  // copy to target buffer\n  copy(target, targetOffset, offset, length) {\n    return this.toBuffer().copy(target, targetOffset, offset, length);\n  }\n\n  toBuffer() {\n    if (!this._buffer) {\n      this._buffer = Buffer.from(this._data, this._encoding);\n    }\n    return this._buffer;\n  }\n}\n\nclass StringBufChunk {\n  constructor(data) {\n    this._data = data;\n  }\n\n  get length() {\n    return this._data.length;\n  }\n\n  // copy to target buffer\n  copy(target, targetOffset, offset, length) {\n    // eslint-disable-next-line no-underscore-dangle\n    return this._data._buf.copy(target, targetOffset, offset, length);\n  }\n\n  toBuffer() {\n    return this._data.toBuffer();\n  }\n}\n\nclass BufferChunk {\n  constructor(data) {\n    this._data = data;\n  }\n\n  get length() {\n    return this._data.length;\n  }\n\n  // copy to target buffer\n  copy(target, targetOffset, offset, length) {\n    this._data.copy(target, targetOffset, offset, length);\n  }\n\n  toBuffer() {\n    return this._data;\n  }\n}\n\n// =============================================================================\n// ReadWriteBuf - a single buffer supporting simple read-write\nclass ReadWriteBuf {\n  constructor(size) {\n    this.size = size;\n    // the buffer\n    this.buffer = Buffer.alloc(size);\n    // read index\n    this.iRead = 0;\n    // write index\n    this.iWrite = 0;\n  }\n\n  toBuffer() {\n    if (this.iRead === 0 && this.iWrite === this.size) {\n      return this.buffer;\n    }\n\n    const buf = Buffer.alloc(this.iWrite - this.iRead);\n    this.buffer.copy(buf, 0, this.iRead, this.iWrite);\n    return buf;\n  }\n\n  get length() {\n    return this.iWrite - this.iRead;\n  }\n\n  get eod() {\n    return this.iRead === this.iWrite;\n  }\n\n  get full() {\n    return this.iWrite === this.size;\n  }\n\n  read(size) {\n    let buf;\n    // read size bytes from buffer and return buffer\n    if (size === 0) {\n      // special case - return null if no data requested\n      return null;\n    }\n\n    if (size === undefined || size >= this.length) {\n      // if no size specified or size is at least what we have then return all of the bytes\n      buf = this.toBuffer();\n      this.iRead = this.iWrite;\n      return buf;\n    }\n\n    // otherwise return a chunk\n    buf = Buffer.alloc(size);\n    this.buffer.copy(buf, 0, this.iRead, size);\n    this.iRead += size;\n    return buf;\n  }\n\n  write(chunk, offset, length) {\n    // write as many bytes from data from optional source offset\n    // and return number of bytes written\n    const size = Math.min(length, this.size - this.iWrite);\n    chunk.copy(this.buffer, this.iWrite, offset, offset + size);\n    this.iWrite += size;\n    return size;\n  }\n}\n\n// =============================================================================\n// StreamBuf - a multi-purpose read-write stream\n//  As MemBuf - write as much data as you like. Then call toBuffer() to consolidate\n//  As StreamHub - pipe to multiple writables\n//  As readable stream - feed data into the writable part and have some other code read from it.\n\n// Note: Not sure why but StreamBuf does not like JS \"class\" sugar. It fails the\n// integration tests\nconst StreamBuf = function(options) {\n  options = options || {};\n  this.bufSize = options.bufSize || 1024 * 1024;\n  this.buffers = [];\n\n  // batch mode fills a buffer completely before passing the data on\n  // to pipes or 'readable' event listeners\n  this.batch = options.batch || false;\n\n  this.corked = false;\n  // where in the current writable buffer we're up to\n  this.inPos = 0;\n\n  // where in the current readable buffer we've read up to\n  this.outPos = 0;\n\n  // consuming pipe streams go here\n  this.pipes = [];\n\n  // controls emit('data')\n  this.paused = false;\n\n  this.encoding = null;\n};\n\nutils.inherits(StreamBuf, Stream.Duplex, {\n  toBuffer() {\n    switch (this.buffers.length) {\n      case 0:\n        return null;\n      case 1:\n        return this.buffers[0].toBuffer();\n      default:\n        return Buffer.concat(this.buffers.map(rwBuf => rwBuf.toBuffer()));\n    }\n  },\n\n  // writable\n  // event drain - if write returns false (which it won't), indicates when safe to write again.\n  // finish - end() has been called\n  // pipe(src) - pipe() has been called on readable\n  // unpipe(src) - unpipe() has been called on readable\n  // error - duh\n\n  _getWritableBuffer() {\n    if (this.buffers.length) {\n      const last = this.buffers[this.buffers.length - 1];\n      if (!last.full) {\n        return last;\n      }\n    }\n    const buf = new ReadWriteBuf(this.bufSize);\n    this.buffers.push(buf);\n    return buf;\n  },\n\n  async _pipe(chunk) {\n    const write = function(pipe) {\n      return new Promise(resolve => {\n        pipe.write(chunk.toBuffer(), () => {\n          resolve();\n        });\n      });\n    };\n    await Promise.all(this.pipes.map(write));\n  },\n  _writeToBuffers(chunk) {\n    let inPos = 0;\n    const inLen = chunk.length;\n    while (inPos < inLen) {\n      // find writable buffer\n      const buffer = this._getWritableBuffer();\n\n      // write some data\n      inPos += buffer.write(chunk, inPos, inLen - inPos);\n    }\n  },\n  async write(data, encoding, callback) {\n    if (encoding instanceof Function) {\n      callback = encoding;\n      encoding = 'utf8';\n    }\n    callback = callback || utils.nop;\n\n    // encapsulate data into a chunk\n    let chunk;\n    if (data instanceof StringBuf) {\n      chunk = new StringBufChunk(data);\n    } else if (data instanceof Buffer) {\n      chunk = new BufferChunk(data);\n    } else if (typeof data === 'string' || data instanceof String || data instanceof ArrayBuffer) {\n      chunk = new StringChunk(data, encoding);\n    } else {\n      throw new Error('Chunk must be one of type String, Buffer or StringBuf.');\n    }\n\n    // now, do something with the chunk\n    if (this.pipes.length) {\n      if (this.batch) {\n        this._writeToBuffers(chunk);\n        while (!this.corked && this.buffers.length > 1) {\n          this._pipe(this.buffers.shift());\n        }\n      } else if (!this.corked) {\n        await this._pipe(chunk);\n        callback();\n      } else {\n        this._writeToBuffers(chunk);\n        process.nextTick(callback);\n      }\n    } else {\n      if (!this.paused) {\n        this.emit('data', chunk.toBuffer());\n      }\n\n      this._writeToBuffers(chunk);\n      this.emit('readable');\n    }\n\n    return true;\n  },\n  cork() {\n    this.corked = true;\n  },\n  _flush(/* destination */) {\n    // if we have comsumers...\n    if (this.pipes.length) {\n      // and there's stuff not written\n      while (this.buffers.length) {\n        this._pipe(this.buffers.shift());\n      }\n    }\n  },\n  uncork() {\n    this.corked = false;\n    this._flush();\n  },\n  end(chunk, encoding, callback) {\n    const writeComplete = error => {\n      if (error) {\n        callback(error);\n      } else {\n        this._flush();\n        this.pipes.forEach(pipe => {\n          pipe.end();\n        });\n        this.emit('finish');\n      }\n    };\n    if (chunk) {\n      this.write(chunk, encoding, writeComplete);\n    } else {\n      writeComplete();\n    }\n  },\n\n  // readable\n  // event readable - some data is now available\n  // event data - switch to flowing mode - feeds chunks to handler\n  // event end - no more data\n  // event close - optional, indicates upstream close\n  // event error - duh\n  read(size) {\n    let buffers;\n    // read min(buffer, size || infinity)\n    if (size) {\n      buffers = [];\n      while (size && this.buffers.length && !this.buffers[0].eod) {\n        const first = this.buffers[0];\n        const buffer = first.read(size);\n        size -= buffer.length;\n        buffers.push(buffer);\n        if (first.eod && first.full) {\n          this.buffers.shift();\n        }\n      }\n      return Buffer.concat(buffers);\n    }\n\n    buffers = this.buffers.map(buf => buf.toBuffer()).filter(Boolean);\n    this.buffers = [];\n    return Buffer.concat(buffers);\n  },\n  setEncoding(encoding) {\n    // causes stream.read or stream.on('data) to return strings of encoding instead of Buffer objects\n    this.encoding = encoding;\n  },\n  pause() {\n    this.paused = true;\n  },\n  resume() {\n    this.paused = false;\n  },\n  isPaused() {\n    return !!this.paused;\n  },\n  pipe(destination) {\n    // add destination to pipe list & write current buffer\n    this.pipes.push(destination);\n    if (!this.paused && this.buffers.length) {\n      this.end();\n    }\n  },\n  unpipe(destination) {\n    // remove destination from pipe list\n    this.pipes = this.pipes.filter(pipe => pipe !== destination);\n  },\n  unshift(/* chunk */) {\n    // some numpty has read some data that's not for them and they want to put it back!\n    // Might implement this some day\n    throw new Error('Not Implemented');\n  },\n  wrap(/* stream */) {\n    // not implemented\n    throw new Error('Not Implemented');\n  },\n});\n\nmodule.exports = StreamBuf;\n"],"mappings":"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"}